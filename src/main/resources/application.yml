# Server Configuration
quarkus:
  http:
    port: 8085
  datasource:
    db-kind: oracle
    username: aaa
    password: Aaa!89nky78D
    reactive:
      url: oracle:thin:@localhost:1522/ORCL
      max-size: 20
      event-loop-size: 8
      idle-timeout: PT15M
      max-lifetime: PT15M
      cache-prepared-statements: true
      reconnect-attempts: 3
      reconnect-interval: PT2S
      shared: false
      name: oracle-pool
      additional-properties:
        oracle.jdbc.implicitStatementCacheSize: "250"
        oracle.jdbc.ReadTimeout: "300000"                  # 5 minutes for large batch operations
        oracle.net.CONNECT_TIMEOUT: "30000"                # Increased to 30s for connection establishment
        oracle.net.READ_TIMEOUT: "300000"                  # Socket-level read timeout (5 minutes)
        oracle.jdbc.loginTimeout: "60"                     # Login timeout in seconds
        oracle.jdbc.defaultRowPrefetch: "100"
        oracle.net.keepAlive: "true"
  otel:
    enabled: false
  #  vertx:
#    event-loops-pool-size: 32
#    max-worker-execute-time: 60
  # Redis Configuration - Optimized for 1000 TPS
  redis:
    hosts: redis://localhost:6379
    timeout: 10s
    max-pool-size: 100
    max-pool-waiting: 200

  log:
    level: INFO
    console:
      format: "%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n"
  console:
    color: true
# Pool Configuration
#pool:
#  max-size: 200                      # Max connections
#  connection-timeout: 5000          # 5 seconds to acquire connection
#  idle-timeout: 6000000              # 10 minutes idle before closing
#  max-lifetime: 18000000             # 30 minutes max connection lifetime
#  acquire-increment: 4              # Connections to acquire at once
#  prepared-statement-cache-max-size: 256  # Cache prepared statements
#  pipelining-enabled: true          # Enable query pipelining
#  pipelining-limit: 400             # Max pipelined queries
#  event-loop-size: 32               # Match vertx event-loops-pool-size
#  tcp-keep-alive: true              # Detect dead connections
#  tcp-no-delay: true                # Reduce latency
#  pool-cleaner-enabled: true        # Clean idle connections
#  pool-cleaner-interval: 60000      # Clean every minute


mp:
  messaging:
    incoming:
      db-write-events:
        connector: smallrye-kafka
        topic: DC-DR
        bootstrap.servers: localhost:9092
        group.id: accounting-dc-group
        value.deserializer: io.quarkus.kafka.client.serialization.ObjectMapperDeserializer
        key.deserializer: org.apache.kafka.common.serialization.StringDeserializer
        auto.offset.reset: earliest
        enable.auto.commit: false          # Changed from true for better reliability
        max.poll.records: 500              # Increased from 100 for higher throughput
        max.poll.interval.ms: 60000        # Reduced from 300000 (5min to 1min)
        session.timeout.ms: 30000
        fetch.min.bytes: 1024              # Minimum bytes to fetch per poll
        fetch.max.wait.ms: 500             # Max wait time for fetch
        max.partition.fetch.bytes: 1048576 # 1MB per partition
        failure-strategy: dead-letter-queue # Changed from ignore to handle failures properly
        dead-letter-queue.topic: DC-DR-DLQ # Dead letter queue topic
        throttled.unprocessed-record-max-age.ms: 60000 # Max age for unprocessed records